using System;
using System.Collections.Generic;
using System.Threading.Tasks;

namespace BobTheDiceMaster.GameOfSchool
{
  /// <summary>
  /// A game of school for a single player with decisions generated by
  /// an <see cref="IPlayer"/> passed to the constructor and dice values
  /// generated by an <see cref="IDie"/> passed to the constructor.
  /// </summary>
  public class GameOfSchoolWithDiceAndAIPlayer : GameOfSchoolWithDice
  {
    private IPlayer aiPlayer;

    public GameOfSchoolWithDiceAndAIPlayer(IGameOfSchool game, IDie dice, IPlayer aiPlayer)
      : base(game, dice)
    {
      this.aiPlayer = aiPlayer;
    }

    /// <summary>
    /// Generate a decision using a player passed through a constructor
    /// and apply it.
    /// Only possible in <see cref="GameOfSchoolState.Rolled"/> game state.
    /// </summary>
    /// <returns>
    /// The decision that was generated and applied.
    /// All the heavyweight computation must be done asynchronously.
    /// </returns>
    public async Task<Decision> GenerateAndApplyDecisionAsync()
    {
      Decision decision = await aiPlayer.DecideOnRollAsync(
        game.AllowedCombinationTypes, CurrentRoll.Roll, RerollsLeft);
      switch (decision)
      {
        case Reroll reroll:
          int[] diceIndexesToReroll = GetDiceIndexesToReroll(reroll.DiceValuesToReroll);
          game.ApplyRerollToDiceAtIndexes(dice.Roll(diceIndexesToReroll.Length), diceIndexesToReroll);
          break;
        case Score score:
          game.ScoreCombination(score.Combination);
          break;
        case CrossOut crossOut:
          game.CrossOutCombination(crossOut.Combination);
          break;
      }
      return decision;
    }

    private int[] GetDiceIndexesToReroll(IReadOnlyCollection<int> diceValuesToReroll)
    {
      int[] diceToReroll = new int[diceValuesToReroll.Count];
      int rerollCounter = 0;
      bool[] dieUsed = new bool[DiceRoll.MaxDiceAmount];
      foreach (int dieValue in diceValuesToReroll)
      {
        for (int i = 0; i < DiceRoll.MaxDiceAmount; ++i)
        {
          if (!dieUsed[i] && CurrentRoll[i] == dieValue)
          {
            diceToReroll[rerollCounter++] = i;
            dieUsed[i] = true;
            break;
          }
        }
      }

      if (rerollCounter < diceValuesToReroll.Count)
      {
        throw new InvalidOperationException(
          $"Current roll {CurrentRoll} does not contain all of the reroll values: {String.Join(",", diceValuesToReroll)}");
      }

      return diceToReroll;
    }
  }
}