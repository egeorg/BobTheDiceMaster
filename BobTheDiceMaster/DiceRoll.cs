using System;
using System.Collections.Generic;
using System.Linq;

namespace BobTheDiceMaster
{
  /// <summary>
  /// Represents a single roll of <see cref="DiceAmount"/> number of dice,
  /// up to <see cref="MaxDiceAmount"/>.
  /// Unlike <see cref="DiceRollDistinct"/> it does not persist dice order and
  /// can be used to compare two rolls ignoring dice order, i.e. only by their values.
  /// Because of that it's useful in internal computations and not suitable for UI.
  /// </summary>
  /// <example>
  /// var roll1 = new DiceRoll(new[] {1, 2, 3, 4, 5});
  /// var roll2 = new DiceRoll(new[] {5, 4, 3, 2, 1});
  /// Console.WriteLine(roll1 == roll2); // "true"
  /// </example>
  public class DiceRoll : IDiceRoll<DiceRoll>
  {

    /// <inheritdoc/>
    public int this[int i]
    {
      get
      {
        return dice[i];
      }
    }

    /// <summary>
    /// Number of dice in the roll.
    /// </summary>
    public int DiceAmount => dice.Length;

    /// <summary>
    /// Maximum number of dice in the roll.
    /// </summary>
    public const int MaxDiceAmount = 5;

    /// <summary>
    /// Create a <see cref="DiceRoll"/> with values from <paramref name="dice"/>.
    /// </summary>
    /// <exception cref="ArgumentException">
    /// Number <paramref name="dice"/> elements is 0 or more than <see cref="MaxDiceAmount"/>.
    /// Or any of <paramref name="dice"/> element is not a valid die value.
    /// </exception>
    public DiceRoll(int[] dice)
    {
      this.dice = (int[])dice.Clone();
      Array.Sort(this.dice);

      if (dice.Length < 1 || dice.Length > MaxDiceAmount)
      {
        throw new ArgumentException(
          $"Between 1 and {MaxDiceAmount} dice expected, but was '{dice.Length}'");
      }

      for (int i = 0; i < dice.Length; ++i)
      {
        if (dice[i] < 1 || dice[i] > D6.MaxValue)
        {
          throw new ArgumentException(
            $"Die value has to be between 1 and {D6.MaxValue}, but {i}-th value was '{dice[i]}'");
        }
      }
    }

    /// <summary>
    /// Sum or dice values from the roll.
    /// </summary>
    public int Sum()
    {
      return dice.Sum();
    }

    /// <summary>
    /// Create a new roll with values generated by the <paramref name="die"/>.
    /// </summary>
    public static DiceRoll GenerateNew(IDie die)
    {
      return new DiceRoll(die.Roll(MaxDiceAmount));
    }

    /// <summary>
    /// Create a new roll with dice at indexes from <paramref name="diceIndexesToReroll"/>
    /// replaced by values generated by the <paramref name="die"/>.
    /// </summary>
    /// <exception cref="ArgumentException">
    /// <paramref name="diceIndexesToReroll"/> contains values out of interval [0, <see cref="DiceAmount"/> - 1].
    /// <paramref name="diceIndexesToReroll"/> contains more than <see cref="DiceAmount"/> values.
    /// </exception>
    public DiceRoll Reroll(int[] diceIndexesToReroll, IDie die)
    {
      int[] diceNew = (int[])dice.Clone();

      int[] dieRollResult = die.Roll(diceIndexesToReroll.Length);

      if (diceIndexesToReroll.Length > dice.Length)
      {
        throw new ArgumentException($"Can't reroll more than {DiceAmount} dice for roll {this}.");
      }
      int dieRollResultCounter = 0;

      foreach (var dieNumber in diceIndexesToReroll)
      {
        if (dieNumber < 0 || dieNumber >= diceNew.Length)
        {
          throw new ArgumentException(
            $"Can't reroll die {dieNumber}. Die number has to be between 0 and {diceNew.Length - 1} inclusively for roll {this}.");
        }
        diceNew[dieNumber] = dieRollResult[dieRollResultCounter++];
      }

      return new DiceRoll(diceNew);
    }

    /// <summary>
    /// Create a new roll with dice values from <paramref name="valuesToReroll"/>
    /// replaced by values generated by <paramref name="die"/>.
    /// </summary>
    /// <exception cref="ArgumentException">
    /// This roll does not contain all of the values from <paramref name="valuesToReroll"/>.
    /// <paramref name="valuesToReroll"/> contains more than <see cref="DiceAmount"/> values.
    /// </exception>
    public DiceRoll RerollByValue(int[] valuesToReroll, IDie die)
    {
      if (valuesToReroll.Length > dice.Length)
      {
        throw new ArgumentException($"Can't reroll more than {DiceAmount} dice for roll {this}.");
      }
      int[] valuesToRerollSorted = (int[])valuesToReroll.Clone();
      Array.Sort(valuesToRerollSorted);

      int[] diceToReroll = new int[valuesToRerollSorted.Length];

      int rollCounter = 0;
      int rerollCounter = 0;

      while (rerollCounter < valuesToRerollSorted.Length
        && rollCounter < MaxDiceAmount)
      {
        if (valuesToRerollSorted[rerollCounter] == dice[rollCounter])
        {
          diceToReroll[rerollCounter] = rollCounter;
          ++rerollCounter;
        }
        ++rollCounter;
      }

      if (rerollCounter < valuesToRerollSorted.Length)
      {
        throw new ArgumentException(
          $"Can't reroll values {{{String.Join(", ", valuesToRerollSorted)}}} for roll {this}, some of the values were not found");
      }

      return Reroll(diceToReroll, die);
    }

    /// <summary>
    /// Create a new roll with dice values from <paramref name="diceIndexesToReroll"/>
    /// replaced by <paramref name="rerollResult">.
    /// </summary>
    /// <exception cref="ArgumentException">
    /// <paramref name="diceIndexesToReroll"/> contains values out of interval [0, <see cref="DiceAmount"/> - 1].
    /// <paramref name="diceIndexesToReroll"/> size differs from <paramref name="rerollResult"/> size.
    /// </exception>
    public DiceRoll ApplyReroll(int[] diceIndexesToReroll, DiceRoll rerollResult)
    {
      if (diceIndexesToReroll.Length != rerollResult.DiceAmount)
      {
        throw new ArgumentException(
          $"Dice to reroll and dice result has to be of the same length, but was: diceIndexesToReroll({diceIndexesToReroll.Length}), rerollResult({rerollResult.DiceAmount})");
      }

      return new DiceRoll(this, diceIndexesToReroll, rerollResult);
    }

    private DiceRoll(DiceRoll roll, int[] diceIndexesToReroll, DiceRoll rerollResult)
    {
      dice = new int[roll.DiceAmount];
      int rollCounter = 0;
      int rerollResultCounter = 0;
      int rerollCounter = 0;
      int resultCounter = 0;

      // merge two sorted arrays, ignore diceIndexesToReroll from roll.
      while (resultCounter < roll.DiceAmount)
      {
        while (rerollCounter < diceIndexesToReroll.Length && rollCounter == diceIndexesToReroll[rerollCounter])
        {
          rollCounter++;
          rerollCounter++;
        }
        if (rollCounter < roll.DiceAmount && (rerollResultCounter >= rerollResult.DiceAmount
          || roll[rollCounter] < rerollResult[rerollResultCounter]))
        {
          dice[resultCounter] = roll[rollCounter];
          resultCounter++;
          rollCounter++;
        }
        else
        {
          dice[resultCounter] = rerollResult[rerollResultCounter];
          resultCounter++;
          rerollResultCounter++;
        }
      }
    }

    /// <summary>
    /// Create a new roll with dice values from <paramref name="valuesToReroll"/>
    /// replaced by <paramref name="rerollResult"/>.
    /// </summary>
    /// <exception cref="ArgumentException">
    /// This roll does not contain all of the values from <paramref name="valuesToReroll"/>.
    /// <paramref name="valuesToReroll"/> size differs from <paramref name="rerollResult"/> size.
    /// </exception>
    public DiceRoll ApplyRerollByValue(int[] valuesToReroll, DiceRoll rerollResult)
    {
      if (valuesToReroll.Length != rerollResult.DiceAmount)
      {
        throw new ArgumentException(
          $"Dice to reroll and dice result has to be of the same length, but was: diceIndexesToReroll({valuesToReroll.Length}), rerollResult({rerollResult.DiceAmount})");
      }

      int[] valuesToRerollCopy = (int[])valuesToReroll.Clone();

      Array.Sort(valuesToRerollCopy);

      int rollCounter = 0;
      int rerollCounter = 0;

      int[] newRollDice = (int[])dice.Clone();

      while (rerollCounter < valuesToRerollCopy.Length
        && rollCounter < MaxDiceAmount)
      {
        if (valuesToRerollCopy[rerollCounter] == dice[rollCounter])
        {
          newRollDice[rollCounter] = rerollResult[rerollCounter];
          ++rerollCounter;
        }
        ++rollCounter;
      }

      if (rerollCounter < valuesToRerollCopy.Length)
      {
        throw new ArgumentException(
          $"Can't reroll values {{{String.Join(", ", valuesToRerollCopy)}}} for roll {this}, some of the values were not found");
      }

      return new DiceRoll(newRollDice);
    }

    /// <summary>
    /// Average score that a player gets if it tries to roll a <paramref name="combination"/>
    /// during a single turn (roll and 2 rerolls).
    /// </summary>
    /// <param name="combination">An elementary combination.</param>
    /// <exception cref="ArgumentException">
    /// A <paramref name="combination"/> is not a valid elementary combination.
    /// </exception>
    public static double AverageScore(CombinationTypes combination)
    {
      if (!combination.IsElementary())
      {
        throw new ArgumentException(
          $"Elementary combination expected, but was {combination}");
      }

      if (!averageScore.ContainsKey(combination))
      {
        throw new ArgumentException(
          $"Unexpected elementary combination: {combination}");
      }

      return averageScore[combination];
    }

    /// <summary>
    /// Score that a <paramref name="combination"/> gives when scored for this roll.
    /// </summary>
    /// <param name="combination">An elementary combination.</param>
    /// <returns>Score that a <paramref name="combination"/> gives when scored for this roll. null if it can't be scored.</returns>
    /// <exception cref="ArgumentException">
    /// A <paramref name="combination"/> is not a valid elementary combination.
    /// </exception>
    public int? Score(CombinationTypes combination)
    {
      switch (combination)
      {
        case CombinationTypes.Grade1:
          return GradeScore(1);
        case CombinationTypes.Grade2:
          return GradeScore(2);
        case CombinationTypes.Grade3:
          return GradeScore(3);
        case CombinationTypes.Grade4:
          return GradeScore(4);
        case CombinationTypes.Grade5:
          return GradeScore(5);
        case CombinationTypes.Grade6:
          return GradeScore(6);
        case CombinationTypes.Pair:
          return PairScore();
        case CombinationTypes.Set:
          return SetScore();
        case CombinationTypes.TwoPairs:
          return TwoPairsScore();
        case CombinationTypes.Care:
          return CareScore();
        case CombinationTypes.Full:
          return FullScore();
        case CombinationTypes.LittleStraight:
          return LittleStraightScore();
        case CombinationTypes.BigStraight:
          return BigStraightScore();
        case CombinationTypes.Poker:
          return PokerScore();
        case CombinationTypes.Trash:
          return Sum();
        default:
          throw new ArgumentException(
            $"Only primitive combinations can be scored, but was {combination}");
      }
    }

    public override string ToString()
    {
      return $"{nameof(DiceRoll)}({String.Join(", ", dice)})";
    }

    /// <summary>
    /// A perfect hash (it's unique for each roll).
    /// </summary>
    public override int GetHashCode()
    {
      int hash = 0;
      for (int i = 0; i < DiceAmount; ++i)
      {
        hash *= 6;
        hash += dice[i];
      }
      return hash;
    }

    public override bool Equals(object obj)
    {
      //GetHashCode is a perfect cache, so it can be used for equality check as well.
      return obj is DiceRoll && GetHashCode() == obj.GetHashCode();
    }

    /// <summary>
    /// All the possible ways to choose dice to reroll.
    /// </summary>
    public static readonly IReadOnlyList<int[]> NonEmptyRerolls = new List<int[]>()
    {
      // It's 2^5 - 1 = 31 variants in total, it does not make sense to generate them,
      // they all can be hardcoded right away (as long as MaxDiceAmount == 5 of course).
      // Can be written as a recursive function or more elegant, but I think it's fine to have it like this.
      new [] { 0 }, new [] { 1 }, new [] { 2 }, new [] { 3 }, new [] { 4 },
      new [] { 0, 1 }, new [] { 0, 2 },  new [] { 0, 3 }, new [] { 0, 4 }, new [] { 1, 2 },
      new [] { 1, 3 }, new [] { 1, 4 }, new [] { 2, 3 }, new [] { 2, 4 }, new [] { 3, 4 },
      new [] { 0, 1, 2}, new [] { 0, 1, 3}, new [] { 0, 1, 4}, new [] { 0, 2, 3},  new [] { 0, 2, 4},
      new [] { 0, 3, 4}, new [] { 1, 2, 3}, new [] { 1, 2, 4}, new [] { 1, 3, 4}, new [] { 2, 3, 4},
      new [] { 0, 1, 2, 3 }, new [] { 0, 1, 2, 4 }, new [] { 0, 1, 3, 4 },new [] { 0, 2, 3, 4 }, new [] { 1, 2, 3, 4 },
      new [] { 0, 1, 2, 3, 4 }
    };

    private int GradeScore(int grade)
    {
      int rollScore = 0;
      for (int i = 0; i < MaxDiceAmount; ++i)
      {
        if (dice[i] == grade)
        {
          rollScore += grade;
        }
      }
      return rollScore;
    }

    

    /// <summary>
    /// Probability is calculated as number of distinct dice rolls that yeild
    /// the numbers specified devided by total number of distinct dice rolls.
    /// Below are examples for 5 dice rolls, similarly for other number of dice:
    /// Total number of possible roll results is 6^5, 6 possible results for each dice.
    /// Number of distinct dice rolls that yield the specific numbers is calculated as follows:
    /// If all dice values are different, it's 5! (one of 5 dice yeilds the
    /// first number, one of 4 dice that left yields the second number, etc.)
    /// It some dice values are repeated, then for each such dice the 5! should be devided
    /// by x! where x is how many times the value occurs in the dice roll result, for example:
    /// For roll (1, 2, 3, 4, 5), probability is 5! / 6^5.
    /// In roll (6,6,6,6,6), 6 appears 5 times =>
    /// 5! / 5! = 1 possible combination, and probability is 1 / 6^5
    /// In roll (1,2,6,6,6), 6 appears 3 times and the rest numbers only once =>
    /// 5! / 3! = 20 combinations, and probability is 20 / 6^5
    /// In roll (5,5,6,6,6), 6 appears 4 times and 5 appears 2 times =>
    /// 5! / (3! * 2!) = 10 combinations, and probability is 10 / 6^5
    /// </summary>
    public double GetProbability()
    {
      // The probabilitiesCache is filled in an InitProbabilities()
      // method that to be called from the static constructor.
      return probabilitiesCache[this];
    }

    // Dice values, it always must be sorted ascending.
    private readonly int[] dice;

    // Precomputed using a BobTheDiceMaster.Precomputer tool, it's in this solution as well.
    private static Dictionary<CombinationTypes, double> averageScore = new Dictionary<CombinationTypes, double>
      {
        { CombinationTypes.Grade1, 2.1064814814814756 },
        { CombinationTypes.Grade2, 4.2129629629629575 },
        { CombinationTypes.Grade3, 6.3194444444444455 },
        { CombinationTypes.Grade4, 8.425925925925913 },
        { CombinationTypes.Grade5, 10.532407407407392 },
        { CombinationTypes.Grade6, 12.6388888888889 },
        { CombinationTypes.Pair, 15.865270870457234 },
        { CombinationTypes.Set, 11.619899714332302 },
        { CombinationTypes.TwoPairs, 16.37926613378522 },
        { CombinationTypes.Full, 7.702210020138647 },
        { CombinationTypes.Care, 4.853220771449692 },
        { CombinationTypes.LittleStraight, 3.183917676890467 },
        { CombinationTypes.BigStraight, 4.245223569187295 },
        { CombinationTypes.Poker, 0.8804221388169133 },
        { CombinationTypes.Trash, 35.100630144032884 }
      };

    private int? PairScore()
    {
      int[] valuesCount = new int[D6.MaxValue];

      for (int i = 0; i < MaxDiceAmount; ++i)
      {
        ++valuesCount[dice[i] - 1];
      }

      for (int i = D6.MaxValue; i > 0; --i)
      {
        if (valuesCount[i - 1] >= 2)
        {
          return 2 * i;
        }
      }

      return null;
    }

    private int? SetScore()
    {
      int[] valuesCount = new int[D6.MaxValue];

      for (int i = 0; i < MaxDiceAmount; ++i)
      {
        ++valuesCount[dice[i] - 1];
      }

      for (int i = D6.MaxValue; i > 0; --i)
      {
        if (valuesCount[i - 1] >= 3)
        {
          return 3 * i;
        }
      }

      return null;
    }

    private int? CareScore()
    {
      int[] valuesCount = new int[D6.MaxValue];

      for (int i = 0; i < MaxDiceAmount; ++i)
      {
        ++valuesCount[dice[i] - 1];
      }

      for (int i = D6.MaxValue; i > 0; --i)
      {
        if (valuesCount[i - 1] >= 4)
        {
          return 4 * i;
        }
      }

      return null;
    }

    private int? TwoPairsScore()
    {
      int[] valuesCount = new int[D6.MaxValue];

      for (int i = 0; i < MaxDiceAmount; ++i)
      {
        ++valuesCount[dice[i] - 1];
      }

      int score = 0;
      for (int i = D6.MaxValue; i > 0; --i)
      {
        // Situation 1: two pairs of single value
        // (basically same as care, but for some reason we want to score it as two pairs)
        if (valuesCount[i - 1] == 4 && score == 0)
        {
          return 4 * i;
        }

        // Situation 2: first pair found
        if (valuesCount[i - 1] >= 2 && score == 0)
        {
          score += 2 * i;
        }
        // Situation 3: second pair found
        else if (valuesCount[i - 1] >= 2 && score > 0)
        {
          return score + 2 * i;
        }
      }

      return null;
    }

    private int? FullScore()
    {
      // dice values are always sorted ascending, hence
      // equal values will always be next to each other.
      if (dice[0] == dice[1]
        && dice[3] == dice[4]
        && (dice[2] == dice[1]
          || dice[2] == dice[3]))
      {
        return Sum();
      }

      return null;
    }

    private int? PokerScore()
    {
      if (dice[0] == dice[1]
        && dice[0] == dice[2]
        && dice[0] == dice[3]
        && dice[0] == dice[4])
      {
        return 5 * dice[0];
      }

      return null;
    }

    private int? LittleStraightScore()
    {
      // dice values are always sorted ascending
      if (dice[0] == 1
        && dice[1] == 2
        && dice[2] == 3
        && dice[3] == 4
        && dice[4] == 5)
      {
        return 15;
      }

      return null;
    }

    private int? BigStraightScore()
    {
      // dice values are always sorted ascending
      if (dice[0] == 2
        && dice[1] == 3
        && dice[2] == 4
        && dice[3] == 5
        && dice[4] == 6)
      {
        return 20;
      }
      return null;
    }

    /// <summary>
    /// All possible reslts of a roll containing <see cref="MaxDiceAmount"/> dice.
    /// </summary>
    public static IReadOnlyList<DiceRoll> RollResultsOfAllDice => rollResultsByDiceAmount[MaxDiceAmount - 1];


    private static List<DiceRoll>[] rollResultsByDiceAmount = new List<DiceRoll>[MaxDiceAmount];

    /// <summary>
    /// All possible reslts of a rolls containing 1 to <see cref="MaxDiceAmount"/> dice.
    /// i-th list corresponds to i+1-dice roll
    /// </summary>
    public static IReadOnlyList<DiceRoll>[] RollResultsByDiceAmount => rollResultsByDiceAmount;

    static DiceRoll()
    {
      // Note: order matters. InitRollResults() has to be called first because
      // InitProbabilities() uses results of InitRollResults()
      InitRollResults();
      InitProbabilities();
    }

    static Dictionary<DiceRoll, double> probabilitiesCache = new Dictionary<DiceRoll, double>();

    private static void InitProbabilities()
    {
      for (int i = 0; i < MaxDiceAmount; ++i)
      {
        foreach (DiceRoll roll in RollResultsByDiceAmount[i])
        {
          probabilitiesCache.Add(roll, roll.CalculateProbability());
        }
      }
    }

    private double CalculateProbability()
    {
      int[] diceHist = new int[D6.MaxValue];
      for (int i = 0; i < dice.Length; ++i)
      {
        ++diceHist[dice[i] - 1];
      }

      long numberOfThrows = Combinatorics.Factorial(dice.Length);

      for (int i = 0; i < D6.MaxValue; ++i)
      {
        numberOfThrows /= Combinatorics.Factorial(diceHist[i]);
      }

      return numberOfThrows / Math.Pow(6, dice.Length);
    }

    private static void InitRollResults()
    {
      for (int i = 0; i < MaxDiceAmount; ++i)
      {
        rollResultsByDiceAmount[i] = new List<DiceRoll>();
      }

      // Can be written as a recursive function or more elegant, but I think it's fine to have it like this
      // (as long as MaxDiceAmount == 5 of course).
      for (int i1 = 1; i1 <= D6.MaxValue; ++i1)
      {
        rollResultsByDiceAmount[0].Add(new DiceRoll(new[] { i1 }));
        for (int i2 = i1; i2 <= D6.MaxValue; ++i2)
        {
          rollResultsByDiceAmount[1].Add(new DiceRoll(new[] { i1, i2 }));
          for (int i3 = i2; i3 <= D6.MaxValue; ++i3)
          {
            rollResultsByDiceAmount[2].Add(new DiceRoll(new[] { i1, i2, i3 }));
            for (int i4 = i3; i4 <= D6.MaxValue; ++i4)
            {
              rollResultsByDiceAmount[3].Add(new DiceRoll(new[] { i1, i2, i3, i4 }));
              for (int i5 = i4; i5 <= D6.MaxValue; ++i5)
              {
                rollResultsByDiceAmount[4].Add(new DiceRoll(new[] { i1, i2, i3, i4, i5 }));
              }
            }
          }
        }
      }
    }
  }
}
