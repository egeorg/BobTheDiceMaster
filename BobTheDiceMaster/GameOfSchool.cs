using System;
using System.Collections.Generic;
using System.Linq;

namespace BobTheDiceMaster
{
  /// <summary>
  /// A game of school for a single player represented by
  /// a <see cref="IPlayer"/> passed to a constructor.
  /// A game for multiple players can be constructed using several
  /// <see cref="GameOfSchool"/> instances in parallel, it does not
  /// have any state shared across different instances.
  /// </summary>
  public class GameOfSchool
  {
    /// <summary>
    /// Latest result of a dice roll.
    /// </summary>
    public DiceRollDistinct CurrentRoll => currentRoll;

    /// <summary>
    /// All the combinations that are left (not scored or crossed out).
    /// </summary>
    public IEnumerable<CombinationTypes> AllowedCombinationTypes =>
      allowedCombinationTypes.GetElementaryCombinationTypes();

    /// <summary>
    /// All the available combinations that can be crossed out.
    /// </summary>
    public IEnumerable<CombinationTypes> CrossOutCombinationTypes =>
      AllowedCombinationTypes.Where(x => !x.IsFromSchool());

    /// <summary>
    /// All the available combinations that can be scored
    /// given actual <see cref="CurrentRoll"/> value.
    /// </summary>
    public IEnumerable<CombinationTypes> ScoreCombinationTypes =>
      AllowedCombinationTypes.Where(x => currentRoll.Roll.Score(x) != null);

    /// <summary>
    /// Current state of game turn.
    /// </summary>
    public GameOfSchoolState State => state;

    /// <summary>
    /// Current game score.
    /// </summary>
    public int Score => totalScore;

    /// <summary>
    /// True iff game is over.
    /// </summary>
    public bool IsGameOver => state == GameOfSchoolState.GameOver;

    /// <summary>
    /// True iff turn a is not in progress: player has rolled the dice, but did not scored or crossed out any combination.
    /// </summary>
    public bool IsTurnOver =>
      state == GameOfSchoolState.Idle
      || state == GameOfSchoolState.GameOver;

    /// <summary>
    /// How many rerolls are left.
    /// </summary>
    public int RerollsLeft => rerollsLeft;

    /// <summary>
    /// Create a new <see cref="GameOfSchool"/> instance for given <see cref="IPlayer"/>
    /// and use the <paramref name="d6"/> to generate roll results when it is delegated to the game.
    /// </summary>
    /// <param name="player"></param>
    /// <param name="d6"></param>
    public GameOfSchool(IPlayer player, IDie d6)
    {
      this.player = player;
      this.d6 = d6;
      Reset();
    }

    /// <summary>
    /// Reset the game: make it as if it did not even start.
    /// </summary>
    public void Reset()
    {
      //TODO: setting roll after reset does not makes sense if game does not generate rolls itself.
      // Also state is idle, but current roll is set, does it makes sense?
      //currentRoll = new DiceRollDistinct(d6.Roll(DiceRoll.MaxDiceAmount));
      allowedCombinationTypes = CombinationTypes.School;
      isSchoolFinished = false;
      totalScore = 0;
      state = GameOfSchoolState.Idle;
    }

    /// <summary>
    /// Generate a new <see cref="CurrentRoll"/>.
    /// Equivalent of a <see cref="SetRoll(DiceRollDistinct)"/>
    /// method, but dice values are generated by the game.
    /// Only possible in <see cref="GameOfSchoolState.Idle"/> game state.
    /// </summary>
    public DiceRollDistinct GenerateRoll()
    {
      VerifyState(GameOfSchoolState.Idle);
      rerollsLeft = RerollsPerTurn;
      currentRoll = new DiceRollDistinct(d6.Roll(DiceRoll.MaxDiceAmount));
      state = GameOfSchoolState.Rolled;
      return currentRoll;
    }

    /// <summary>
    /// Set value of <see cref="CurrentRoll"/> to <paramref name="roll"/>.
    /// Equivalent of a <see cref="GenerateRoll">
    /// method, but dice values are passed as an argument.
    /// Only possible in <see cref="GameOfSchoolState.Idle"/> game state.
    /// </summary>
    public void SetRoll(DiceRollDistinct roll)
    {
      VerifyState(GameOfSchoolState.Idle);
      //TODO: does it affect anything? Seems that everything worked without it.
      rerollsLeft = RerollsPerTurn;
      this.currentRoll = roll;
      state = GameOfSchoolState.Rolled;
    }

    /// <summary>
    /// Generate a reroll result and apply it to a <see cref="CurrentRoll"/>.
    /// Dice to be rerolled has to be set earlier by
    /// a <see cref="ApplyDecision(Decision)"/> method with an argument of type <see cref="Reroll"/>.
    /// Equivalent of a <see cref="ApplyReroll(int[])"/>
    /// method, but dice values are generated by the game.
    /// Only possible in <see cref="GameOfSchoolState.Rolled"/> game state.
    /// </summary>
    public void GenerateAndApplyReroll()
    {
      VerifyState(GameOfSchoolState.Rolled);
      currentRoll = currentRoll.RerollIndexes(diceIndexesToReroll, d6);
    }

    /// <summary>
    /// Shorcut, it's basically the same as calling
    /// <see cref="ApplyDecision(Decision)"/> with a <see cref="Reroll"/>
    /// argument and then <see cref="GenerateAndApplyReroll"/>.
    /// Only possible in <see cref="GameOfSchoolState.Rolled"/> game state.
    /// </summary>
    public void GenerateAndApplyReroll(int[] diceIndexesToReroll)
    {
      VerifyState(GameOfSchoolState.Rolled);
      DecrementRerollsLeft();
      currentRoll = currentRoll.RerollIndexes(diceIndexesToReroll, d6);
    }

    /// <summary>
    /// Apply a reroll result <paramref name="reroll"/> to a <see cref="CurrentRoll"/>.
    /// Dice to be rerolled has to be set earlier by
    /// a <see cref="ApplyDecision(Decision)"/> method with an argument of type <see cref="Reroll"/>.
    /// Equivalent of a <see cref="GenerateAndApplyReroll">
    /// method, but dice values are passed as an argument.
    /// Only possible in <see cref="GameOfSchoolState.Rolled"/> game state.
    /// </summary>
    public void ApplyReroll(int[] reroll)
    {
      VerifyState(GameOfSchoolState.Rolled);
      currentRoll = currentRoll.ApplyRerollAtIndexes(diceIndexesToReroll, new DiceRollDistinct(reroll));
    }

    /// <summary>
    /// Generate a decision using a player passed through a constructor
    /// and apply it.
    /// Only possible in <see cref="GameOfSchoolState.Rolled"/> game state.
    /// </summary>
    public Decision GenerateAndApplyDecision()
    {
      VerifyState(GameOfSchoolState.Rolled);
      Decision decision = player.DecideOnRoll(
        allowedCombinationTypes, currentRoll.Roll, rerollsLeft);
      ApplyDecision(decision);
      return decision;
    }

    /// <summary>
    /// Apply a decision passed as an argument.
    /// Can be used as an equivalent of a <see cref="GenerateAndApplyDecision"/>
    /// method where decision is passed as an argument without involving a player
    /// passed to the constructor.
    /// Only possible in <see cref="GameOfSchoolState.Rolled"/> game state.
    /// </summary>
    public void ApplyDecision(Decision decision)
    {
      VerifyState(GameOfSchoolState.Rolled);
      switch (decision)
      {
        case Reroll reroll:
          DecrementRerollsLeft();
          diceIndexesToReroll = GetDiceIndexesToReroll(reroll.DiceValuesToReroll);
          break;
        case Score score:
          if (!allowedCombinationTypes.HasFlag(score.CombinationToScore))
          {
            throw new InvalidOperationException(
              $"Combination {score.CombinationToScore} is already used");
          }
          if (currentRoll.Roll.Score(score.CombinationToScore) == null)
          {
            throw new InvalidOperationException(
              $"Combination {score.CombinationToScore} can't be scored for roll {currentRoll}");
          }
          if (rerollsLeft == RerollsPerTurn
            && !score.CombinationToScore.IsFromSchool())
          {
            totalScore += currentRoll.Roll.Score(score.CombinationToScore).Value * 2;
          }
          else
          {
            totalScore += currentRoll.Roll.Score(score.CombinationToScore).Value;
            //TODO[GE]: move somewhere
            switch (score.CombinationToScore)
            {
              case CombinationTypes.Grade1:
                totalScore -= 5;
                break;
              case CombinationTypes.Grade2:
                totalScore -= 10;
                break;
              case CombinationTypes.Grade3:
                totalScore -= 15;
                break;
              case CombinationTypes.Grade4:
                totalScore -= 20;
                break;
              case CombinationTypes.Grade5:
                totalScore -= 25;
                break;
              case CombinationTypes.Grade6:
                totalScore -= 30;
                break;
            }
          }
          allowedCombinationTypes -= score.CombinationToScore;
          state = GameOfSchoolState.Idle;
          break;
        case CrossOut crossOut:
          if (!allowedCombinationTypes.HasFlag(crossOut.Combination))
          {
            throw new InvalidOperationException($"Combination {crossOut.Combination} is already used");
          }
          if (crossOut.Combination.IsFromSchool())
          {
            throw new InvalidOperationException($"Can't cross out combination {crossOut.Combination}. Can't cross out combinations from school");
          }
          allowedCombinationTypes -= crossOut.Combination;
          state = GameOfSchoolState.Idle;
          break;
      }
      if (!isSchoolFinished && AreThreeGradesFinished(allowedCombinationTypes))
      {
        allowedCombinationTypes |= CombinationTypes.AllButSchool;
      }

      if (allowedCombinationTypes == CombinationTypes.None)
      {
        state = GameOfSchoolState.GameOver;
      }
    }

    private IPlayer player;
    private IDie d6;
    private const int RerollsPerTurn = 2;

    private DiceRollDistinct currentRoll;
    private int[] diceIndexesToReroll;
    private int rerollsLeft;
    private int totalScore;
    private CombinationTypes allowedCombinationTypes;
    private bool isSchoolFinished;
    private GameOfSchoolState state;

    private bool AreThreeGradesFinished(CombinationTypes combinationTypes)
    {
      if (!combinationTypes.IsFromSchool())
      {
        throw new ArgumentException($"Only grade combinations expected, but was {combinationTypes}");
      }
      uint gradesLeft = 0;
      uint combinationTypesUint = (uint)combinationTypes;
      while (combinationTypesUint != 0)
      {
        gradesLeft += combinationTypesUint % 2;
        combinationTypesUint = combinationTypesUint >> 1;
      }

      if (gradesLeft > 3)
      {
        return false;
      }
      isSchoolFinished = true;
      return true;
    }

    private void VerifyState(GameOfSchoolState requiredState)
    {
      if (state == requiredState)
      {
        return;
      }

      switch (state)
      {
        case GameOfSchoolState.Idle:
          throw new InvalidOperationException(
            "Dice were not rolled yet. Use GenerateRoll or SetRoll");
        case GameOfSchoolState.Rolled:
          throw new InvalidOperationException(
            "Previous turn is not over yet. Use GenerateReroll, ApplyDecision or GenerateAndApplyDecision");
        case GameOfSchoolState.GameOver:
          throw new InvalidOperationException("Game is over. Start a new game.");
        default:
          throw new InvalidOperationException($"Unexpected game state: {state}.");
      }
    }

    private int[] GetDiceIndexesToReroll(IReadOnlyCollection<int> diceValuesToReroll)
    {
      int[] diceToReroll = new int[diceValuesToReroll.Count];
      int rerollCounter = 0;
      bool[] dieUsed = new bool[DiceRoll.MaxDiceAmount];
      foreach (int dieValue in diceValuesToReroll)
      {
        for (int i = 0; i < DiceRoll.MaxDiceAmount; ++i)
        {
          if (!dieUsed[i] && currentRoll[i] == dieValue)
          {
            diceToReroll[rerollCounter++] = i;
            dieUsed[i] = true;
            break;
          }
        }
      }

      if (rerollCounter < diceValuesToReroll.Count)
      {
        throw new InvalidOperationException(
          $"Current roll {currentRoll} does not contain all of the reroll values: {String.Join(",", diceValuesToReroll)}");
      }

      return diceToReroll;
    }

    private void DecrementRerollsLeft()
    {
      if (rerollsLeft == 0)
      {
        throw new InvalidOperationException("No rerolls are left, can't reroll the dice");
      }
      --rerollsLeft;
    }
  }
}
