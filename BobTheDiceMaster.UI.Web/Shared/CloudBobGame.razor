<div style="display:inline-block; vertical-align:top">
  <div style="display:inline-block">
    <div style="margin:10px">
      <div style="width:200px; display:inline-block">
        <Die Value="@currentRoll[0]" Id="bobDie1" @bind-IsSelected="@diceSelected[0]" IsDisabled="true" />
        <Die Value="@currentRoll[1]" Id="bobDie2" @bind-IsSelected="@diceSelected[1]" IsDisabled="true" />
        <Die Value="@currentRoll[2]" Id="bobDie3" @bind-IsSelected="@diceSelected[2]" IsDisabled="true" />
        <Die Value="@currentRoll[3]" Id="bobDie4" @bind-IsSelected="@diceSelected[3]" IsDisabled="true" />
        <Die Value="@currentRoll[4]" Id="bobDie5" @bind-IsSelected="@diceSelected[4]" IsDisabled="true" />
      </div>
    </div>
    <div style="margin:10px">
      <button @onclick="Next" disabled="@isNextDisabled">Next</button>
    </div>
    <div style="margin:10px">
      Score: @game.Score
    </div>
    <div style="margin:10px">
      @if (@game.AllowedCombinationTypes.Any())
      {
        <p>Combinations left:</p>

        <br />
        @foreach (CombinationTypes allowedCombination in @game.AllowedCombinationTypes)
        {
          @allowedCombination

          <br />
        }
      }
      else
      {
        <p>Game over!</p>
      }
    </div>
  </div>
  <div style="display:inline-block; vertical-align:top">
    Bob: <br />
    @if (isWaiting)
    {
      <p>Thinking...</p>
    }
    else
    {
      <p>Waiting for yout input</p>
    }
    @foreach (var message in @messages)
    {
      <p>@message<br /></p>
    }
  </div>
</div>

@code {
  [Parameter]
  public bool IsActive { get; set; } = true;
  [Parameter]
  public EventCallback<bool> OnTurnCompleted { get; set; }

  protected override async Task OnParametersSetAsync()
  {
    if (IsActive && isActive != IsActive)
    {
      await Next();
    }
    isActive = IsActive;
  }

  private bool isActive;

  private DiceRollDistinct currentRoll = new DiceRollDistinct(new[] { 2, 2, 4, 4, 6 });

  private GameOfSchool game = new GameOfSchool(new VerboseBruteForceBob());

  private bool[] diceSelected = new[] { false, false, false, false, false };

  private bool isNextDisabled => !IsActive || isWaiting;

  private bool isWaiting { get; set; } = false;

  private List<string> messages = new List<string>();

  const string bobApiAddress = "https://epjlghh8jh.execute-api.eu-central-1.amazonaws.com/";
  //const string bobApiAddress = "https://localhost:51777/";

  private void ResetRolls()
  {
    for (int i = 0; i < DiceRoll.MaxDiceAmount; ++i)
    {
      diceSelected[i] = false;
    }
  }

  protected override void OnInitialized()
  {
    currentRoll = game.GenerateRoll();
  }

  private void AddMessage(string message)
  {
    messages.Add(message);
    StateHasChanged();
  }

  private void MethodNeverCalled()
  {
    new SortedSet<int>();
  }

  private Decision ConvertSwaggerToCore(Api.SwaggerClient.Decision apiDecision)
  {
    if (apiDecision.Reroll != null)
    {
      return new Reroll(apiDecision.Reroll.ValuesToReroll);
    }
    else if (apiDecision.Score != null)
    {
      return new Score((CombinationTypes)apiDecision.Score.Combination);
    }
    else if (apiDecision.Score != null)
    {
      return new Score((CombinationTypes)apiDecision.Score.Combination);
    }
    else
    {
      throw new InvalidOperationException(
        $"All {typeof(BobTheDiceMaster.Api.SwaggerClient.Decision)} fields are null");
    }
  }

  private async Task Next()
  {
    isWaiting = true;
    messages.Clear();
    bool hasError = false;
    while (!game.IsTurnOver && !hasError)
    {
      try
      {
        Decision decision = await DecideOnRoll();
        AddMessage($"For {game.CurrentRoll} I decide to {decision}.");

        game.ApplyDecision(decision);

        if (decision is Reroll)
        {
          game.GenerateAndApplyReroll();
        }
      }
      catch (Exception e)
      {
        AddMessage(e.ToString());
        hasError = true;
      }
    }

    if (!game.IsGameOver)
    {
      currentRoll = game.GenerateRoll();
    }

    isWaiting = false;
    await OnTurnCompleted.InvokeAsync();
  }

  private async Task<Decision> DecideOnRoll()
  {
    DateTime startRequestTime = DateTime.UtcNow;
    using HttpClient httpClient = new HttpClient();
    var bobClient = new BobTheDiceMaster.Api.SwaggerClient.BobApiClient(bobApiAddress, httpClient);

    var gameContext = new Api.SwaggerClient.GameOfSchoolContext();
    gameContext.AvailableCombinations = (Api.SwaggerClient.CombinationTypes)game.AllowedCombinationTypes.Aggregate(CombinationTypes.None, (a, b) => a | b);
    gameContext.DiceRoll = Enumerable.Range(0, game.CurrentRoll.Roll.DiceAmount)
        .Select(n => game.CurrentRoll.Roll[n]).ToArray();
    gameContext.RollsLeft = game.RerollsLeft;

    var decision = await bobClient.DefaultBobDecideOnRollAsync(
        gameContext);
    AddMessage($"Request took '{DateTime.UtcNow - startRequestTime}'");

    return ConvertSwaggerToCore(decision);
  }


}